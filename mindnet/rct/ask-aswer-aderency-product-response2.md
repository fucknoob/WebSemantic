# colect objects# pondere aderencias# tds os results para cada categoria estaram no to_posting# LEVEL(1)->caracts/class/...# LEVEL(2)->eventos# LEVEL(3)->place# LEVEL(4)->exceptionsractionline filter_collects_pr2  factname apps_collect_s_filterc2  # colletar por obj+ filter + refer(links)  fact apps_collect_s_filterc2   interface identificador,rename,filter   identificador $$all$$   #rename identificador,object   # criar alias de class como alis( topico a ser filtrado  )   #rename class,alias   # criar alias de except(exessao)   #rename except,refer   refer sugest   alias   filterend# so para pegar os names object2ractionline fil_get_ids_ow_r2  factname get_ide_from_obj_r2  fact get_ide_from_obj_r2   object $$all$$   rename object,identificador   no_returnendractionline process_aderencia_filter2r  layoutcode apps_collects_products_printresult2  # pps_aderencia_with_cenario normal, dependendo depassar pela geracao de cenario as caracts a serem testadas  #factname apps_aderencia_with_cenario  #1.->object@dest-topico  #2.->object@opcode-link@dest-topico  #3.->object-@topico-relevante-remote@topico-read(p/ competar dt)@dest-topico  # diretamente de um obj  #factname apps_aderencia_with_cenario(obj_rule_objs@rule@rule)  # por destination  factname apps_aderencia_with_cenarioxz($$all$$@purp-adere-product@dest@rule)  fact apps_aderencia_with_cenarioxz     interface  raw_afininity,identificador     # id => $cache, pois vai usar os coletados na rct filter_collects_pr ou diretamente o identificador dos objetos coletados     # se inibir o identificador, a busca sera mais ampla e nao por usuario     identificador $$all$$     # dest -> tipo de destination(purpose) a procurar para identificar os objetos em questao     dest $rule-destination-for-objects     # adicional plus     #plus     # rule vai ser fornecido pelo cenario, ou por find-path, onde vai determinar as caracts para coletar     rule     # dfin simbolo para 'explode'/'parser' de um topico em varios do parametro rule     dfin >     # sins-> sinapses do fpath, o seja, dos links dos objetos que podem ser percorridos quando identificador fornecidor, para encontrar layers likados e conferir     sins sugest,need,guess     # tag-> identif do find-path q implementou o fact na hora de rodar     tag     # tstatic -> retorna fixo no resultado coletado e '&' serve pra determinar levels     #tstatic kkk&mmm,nnn,ooo     raw_afininityend# cria um formato de output para cada situacao de resposta, permitindo formatar uma msg de assunto personalizado,#  a ser chamado pelo  print_result_obj_to_publish_el, quando tem formatos mais complexos de retornoractionline publish_with_layoutendractionline print_result_obj_to_publish  layoutcode filter_class_end  factname print_result_obj_to_publish1  fact print_result_obj_to_publish1   tstatic modelo,de   identificador $$all$$   tstatic proprio,acabado   tag http:  returns $inverse,rctline,ret_obj_by_class_recursive2,noneendractionline print_result_obj_to_publish_el  layoutcode filter_class_end  factname print_result_obj_to_publish1_el  fact print_result_obj_to_publish1_el   # serialize -> se constar como iinstrucao, os elementos do fact deveram estar na mesma sequencia q os topicos do objetc, em serie, igual ao uma fuzzy, para validar, nao pode conter os topicos do fact validados em qualquer ordem no objeto referencia   identificador $$all$$   # tag --> stop-point do filter por mean.class   tag http:   # class + objeto [ genero ], se nao identificar, chama o generico, q só analiza o tag   interact.genero $$all$$   returns $inverse,rctline,print_result_obj_to_publish,noneend# desce cada item do link ate achar a ponta(retonar zero, onde o layout onto filter_class_end vai considerar o ultimo sucedido, pois apaga td o resultado a cada vez q teve sucesoractionline ret_obj_by_class_recursive2  factname class_filter_obj2prcsds2  fact class_filter_obj2prcsds2    interface filter,identificador,returns    #=========================    # $stack -> objetos coletados anteriormente    identificador $stack    alias    reverse on    refer class    # reverse --> se a analize de links segue o caminho oposto ( da fim pro inicio) ao contrato do convencionar(do inicio pro fim)    filter    # return -> regra de validacao de execussao alternativa ao  need : found : , e q deve ser associado a um layers_collect_s($stack) | a existencia de um objeto($object)->return $object objeto_nome_na_base | a existencia socedida de published ($pub) object_nome_na_base | a existencia de topicos ou data no layer ou seja nao empty ($top) object_nome_na_base | a nao existencia de topicos ou data no layer ou seja empty ($empty) object_nome_na_base    returns $stack  call print_result_obj_to_publish_elend# desce cada item do link ate achar a ponta(retonar zero, onde o layout onto filter_class_end vai considerar o ultimo sucedido, pois apaga td o resultado a cada vez q teve sucesoractionline ret_obj_by_class_recursive  factname class_filter_obj2prcsds  fact class_filter_obj2prcsds    interface filter,identificador,returns    #=========================    # $stack -> objetos coletados anteriormente    identificador $stack    alias    refer class    reverse on    # reverse --> se a analize de links segue o caminho oposto ( da fim pro inicio) ao contrato do convencionar(do inicio pro fim)    filter    # return -> regra de validacao de execussao alternativa ao  need : found : , e q deve ser associado a um layers_collect_s($stack) | a existencia de um objeto($object)->return $object objeto_nome_na_base | a existencia socedida de published ($pub) object_nome_na_base | a existencia de topicos ou data no layer ou seja nao empty ($top) object_nome_na_base | a nao existencia de topicos ou data no layer ou seja empty ($empty) object_nome_na_base    returns $stack  call print_result_obj_to_publish_elendractionline ret_obj_by_class  factname class_filter_obj  fact class_filter_obj    interface retag,rename,filter,returns    mandator retag    #=========================    retag $$all$$    alias    refer class    reverse on    # reverse --> se a analize de links segue o caminho oposto ( da fim pro inicio) ao contrato do convencionar(do inicio pro fim)    rename retag,identificador    filter    returns $stack  call print_result_obj_to_publish_elendractionline get_process_actions  layoutcode monta_perfil_cliente  factname get_process_actionsfctvari  factname get_process_actionsfct3($$all$$@purp-destin@dest@rule)  fact get_process_actionsfctvari     interface  variancy,identificador     identificador $$all$$     # s> -> tira plural, >s poe plural     variancy R,os>o,as>a,a>as,o>os        fact get_process_actionsfct3     interface  raw_afininity,identificador     identificador $stack     dest purp-adere-action     rule     dfin >     sins action.play,action.travel,action.party     tag     raw_afininity     write tag.tag->retagendractionline process_aderencia_filter3r  layoutcode apps_collects_products_printresult2  # pps_aderencia_with_cenario normal, dependendo depassar pela geracao de cenario as caracts a serem testadas  #factname apps_aderencia_with_cenario  #1.->object@dest-topico  #2.->object@opcode-link@dest-topico  #3.->object-@topico-relevante-remote@topico-read(p/ competar dt)@dest-topico  # diretamente de um obj  #factname apps_aderencia_with_cenario(obj_rule_objs@rule@rule)  # por destination  factname apps_aderencia_with_cenarioxz3vari  factname apps_aderencia_with_cenarioxz3($$all$$@purp-destin@dest@rule)  fact apps_aderencia_with_cenarioxz3vari     interface  variancy,identificador     identificador $$all$$     # s> -> tira plural, >s poe plural     variancy R,os>o,as>a,a>as,o>os       fact apps_aderencia_with_cenarioxz3     interface  raw_afininity,identificador,rename,write,returns     # id => $cache, pois vai usar os coletados na rct filter_collects_pr ou diretamente o identificador dos objetos coletados     # se inibir o identificador, a busca sera mais ampla e nao por usuario     identificador $stack     # dest -> tipo de destination(purpose) a procurar para identificar os objetos em questao     dest purp-adere-class     # adicional plus     #plus     # rule vai ser fornecido pelo cenario, ou por find-path, onde vai determinar as caracts para coletar     rule     # dfin simbolo para 'explode'/'parser' de um topico em varios do parametro rule     dfin >     # sins-> sinapses do fpath, o seja, dos links dos objetos que podem ser percorridos quando identificador fornecidor, para encontrar layers likados e conferir     sins sugest,need,guess     # tag-> identif do find-path q implementou o fact na hora de rodar     tag     # tstatic -> retorna fixo no resultado coletado e '&' serve pra determinar levels     #tstatic kkk&mmm,nnn,ooo     raw_afininity     write tag.tag->retag     returns $stack     # chama ret_obj_by_class somente se retornou algo no raw_Affinity  # retornar o objeto(s) pertence a classe encontrada  call ret_obj_by_classend#################################################### finalizacao dos elementos encontrados por data ou intervalo.#ractionline consulta_data_okendractionline consulta_data_intervalo_okend###################################################ractionline process_analize_data_intervalo   factname process_data_intervalo_ftc   fact process_data_intervalo_ftc    interface behav,interact.state.moment.start-data,interact.state.moment.end-data,returns    event $next-week    # data a ser comparado o intervalor, fornecido pela oferta    datacomparar interact.data.model    # data de inicio    interact.state.moment.start-data $$all$$    # data de fim , fornecido pelo ask pedindo um intervalo valido    interact.state.moment.end-data $$all$$    behav datacomparar,interact.state.moment.start-data,interact.state.moment.end-data,retorno    returns $top2,retornoc    call consulta_data_intervalo_okendractionline process_event_compare_off   #compare in[]   #  data   # find-path para achar aderencias de datas em ofertas   factname process_event_compare_off_fct($$all$$@purp-destin@event@interact.moment.date)   fact process_event_compare_off_fct    event    dfin >    sins sugest,need,guess    tag    raw_afininity    returns $stack    call consulta_data_okendractionline process_analize_data_formato_base  factname process_analize_data_formato_fct_base  fact process_analize_data_formato_fct_base    interface relative,interact.state.moment.daterel1,interact.state.moment.date,interact.state.moment.daterel2    mandator interact.state.moment.date    interact.state.moment.date $$all$$    interact.state.moment.daterel2 $$all$$    interact.state.moment.daterel1 $$all$$    relative interact.state.moment.date,interact.state.moment.daterel2,interact.state.moment.daterel1    #se nao tiver uma base de traducao, passar para modelo sem base  call process_event_compare_offend#intervalo -->ractionline process_analize_data_formato_base_interv_mul2  factname process_analize_data_formato_fct_base_interv_mul2  fact process_analize_data_formato_fct_base_interv_mul2    interface relative,interact.state.moment.start-data,interact.state.moment.end-data,interact.state.moment.daterel1,interact.state.moment.daterel2    mandator  interact.state.moment.start-data,interact.state.moment.end-data    # data de inicio    interact.state.moment.start-data $$all$$    interact.state.moment.end-data $$all$$    interact.state.moment.daterel1 $$all$$    interact.state.moment.daterel2 $$all$$    #=========== verificar se tem q traduzir as datas relativas    relative interact.state.moment.start-data,interact.state.moment.daterel1,interact.state.moment.daterel2    relative interact.state.moment.end-data,interact.state.moment.daterel1,interact.state.moment.daterel2    #    code-trans $date-interval    # retorna intervalo de datas entre o star-date e end-data    relative code-trans,interact.state.moment.start-data,interact.state.moment.end-data    write code-trans->event  call process_event_compare_offendractionline process_filter_events  # actions  # datas  #  .translate  #  .compare with oferts (  process_event_compare_off)  # testar intervalos  call process_event_compare_off22  # testar datas  call process_analize_data_formato_baseendractionline ask-aswer-aderency-product-response2  #coletar class links , class definitions sobre um obj  call filter_collects_pr2  call fil_get_ids_ow_r2  # process_aderencia_filter2r -> procura affinity por defs  #call process_aderencia_filter2r  # process_aderencia_filter3r -> procura affinity por class  call process_aderencia_filter3r  # processar por perfil  call get_process_actionsend