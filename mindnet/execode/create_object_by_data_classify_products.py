#EXEC
import mdNeuralimport umiscimport mdTbimport mdER
def runc_layer(layer,usr):

    not_in=['event','start','number','class-past','person','assunto','simple-collect','sample','equilibrio','know','mean','qtd-','time','indicative','interact','state','accept','way','need','intensity','grow','order','simple-','value','enum','event','news','referencial','compare','number','ele','ela']    not_in2=['class-past','start-past']    not_in3=['e','do','da','dos','das']    not_in4=['state','event','start']    ref_opcode=''    global_uuid=0    if True:       print 'RTS(1--2-I)('+layer.name+'):------------'       r=layer       for s in r.topicos:         if s.uuid > 0 :          global_uuid=s.uuid         print 'Topico:',s.dt         print 'SNS:------------------------------------------'         for s1 in s.sinapses:           print '           ',s1.nr.dt           for s2 in s1.nr.sinapses:             print '                        ',s2.nr.dt         print '----------------------------------------------'       print 'RTS(1--2-I)(END):------------'    obj_foco=[]    prop_l=False    abs_cnt=1    #print 'N tops:' , len(layer.topicos)    topics=[]    reins_tps=[]    for t in layer.topicos:      if 'object' in t.dt or 'identificador' in t.dt:        for sn in t.sinapses:          ah=False          for a in sn.nr.dt:           for cin in not_in:            if cin in a.lower():             ah=True             continue          if ah:           reins_tps.append(sn.nr)    for t in layer.topicos:      if 'tstatic' in t.dt : # se tstatic, avalia apenas os topicos abaixo desse       for s1 in t.sinapses:        topics.append(s1.nr)      else:        topics.append(t)    found_by_name=False    if True:       if umisc.trim(layer.name) != '$$id$$' and umisc.trim(layer.name)!='':         lay=mdNeural.mdLayer()         lay.name=layer.name         #===         obj_foco.append(lay)         found_by_name=True
    for t in topics:        tp=t        nr_t=t.dt[0]        if nr_t == '': continue        if 'object' in t.dt or 'identificador' in t.dt and not found_by_name:         sn_dt=''         for sn in tp.sinapses:          for s1 in sn.nr.dt:           print 'Object.fnd:',s1,'->>',t.dt           sn_dt+=(s1+' ')
         rts=layer.s_get_ontology_ponderate(sn_dt,[],[],usr )         for [ratting,la] in rts:          obj_foco.append(la)          break         if len(rts) == 0:          if umisc.trim(sn_dt) != '$$id$$':           lay=mdNeural.mdLayer()           lay.name=sn_dt           #===           tp_rc=lay.get_topico('tag')           if tp_rc == None:            tp_rc=lay.set_topico('tag')           tp_rc.uuid=global_uuid           lay.set_nr_ch(tp_rc,'http:','defs')           #===           obj_foco.append(lay)           #===
    if len(obj_foco) == 0: # nao descreve um layer, ? o proprio layer      obj_foco.append(layer)      prop_l=True    i_class=[]    i_category=[]    for t in layer.topicos:     reins_tps.append(t)    for t in reins_tps:        topico_rsf=t        rel1=False        ref_opcode=t.dt[0]        #==============================================        if str(ref_opcode) in ['class'] :          i_class.append(t)        #=============================================        if str(ref_opcode) in ['category'] :          i_category.append(t)        #==============================================        if str(ref_opcode) in ['interact.genero','interact.mode.mark','interact.mode.news','interact.mode.purpose','interact.mode.collection'] :         for la in obj_foco:          la.set_topico_nr(t)    #===========================================================================    # class    #===========================================================================    cl_fnd=False    cn_cl=[]    ls_link =[]    print 'Process definition:',i_class    if not cl_fnd:# criar um objeto __abstract__ e implementar com o class recolhido           dtnm=''           ah=False           ah2=False           to_class_impl=[]           for c_i in i_class:              for sn in c_i.sinapses:                 to_class_impl.append(sn.nr)
           if len(to_class_impl) > 0 :            for la in obj_foco:             print 'Parse layers defin:',to_class_impl             laycl=la             #======================================================             for cl_impl_nr in to_class_impl:               tps=laycl.get_topico('defs')               if tps == None:                tps=laycl.set_topico('defs')               laycl.set_nr_ch_a2(tps,cl_impl_nr,'Composicao')             #======================================================    print '[global_uuid]:',global_uuid
    ls_link=[]    obj_foco2=[]    #===========================================================================    # category    #===========================================================================    cl_fnd=False    cn_cl=[]    ls_link =[]    print 'Process category(class):============================================='    for i in i_category:     print i.dt     print '  ------'     for dkl in i.sinapses:       print '   ',dkl.nr.dt    print '====================================================================='    i_category2=[]    if True:# criar um objeto __abstract__ e implementar com o class recolhido           dtnm=''           ah=False           ah2=False           to_class_impl=[]           lays=[]           ind=-1           lenc=len(i_category)           ant=''           for c_i in i_category:              ind+=1              for sn in c_i.sinapses:                to_class_impl=sn.nr.dt                if to_class_impl[0] in ['interact.genero','start']: continue                #==================                if to_class_impl[0] == ',' or ind==(lenc-1) :                 if ant != '' :                  if ant != 'end':                   laycl=mdNeural.mdLayer()                   laycl.name=umisc.trim(ant).lower()                   lays.append(laycl)                   i_category2.append(laycl.name)                   print 'process link pr in:',ant                  ant=''                else:                  ant+=to_class_impl[0]+' '                break           if umisc.trim(ant) != '' and ant!= 'end'   :                   laycl=mdNeural.mdLayer()                   laycl.name=umisc.trim(ant).lower()                   lays.append(laycl)                   i_category2.append(laycl.name)           lenk=len(lays)-1           for il in lays:               obj_foco2.append(il)           ant_lay=None           first_one=None           while lenk >=0 :               #               if ant_lay != None:                ant_lay.set_link_ds(lays[lenk],'class','','')                print 'link:',ant_lay.name,' to:',lays[lenk].name               ant_lay=lays[lenk]               if first_one == None:                first_one=lays[lenk]               #               lenk-=1           laycl=first_one           #======================================================           #           if laycl != None:               #fixar link com o foco               print 'connect principal link:',laycl.name               for ob in obj_foco:                ob.set_link_ds(laycl,'class','','')
    '''ractionline cenario_objs_importantes_ecomm  factname cenario_objs_importantes_ecomm1  factname cenario_objs_importantes_ecomm21  factname cenario_objs_importantes_identification  # cada fact implementa um conjunto de caracteristicas, elementos para identificar um tipo de object  #  assim varios facts podem implementar varios search por objetos diferentes  fact cenario_objs_importantes_ecomm1   purp-destin $rule-destination-for-objects   rule defs>Harry   rule defs>Potter  fact cenario_objs_importantes_ecomm21    purp-destin $rule-destination-for-objects    rule defs>interaction.get.action>viagem    rule defs>interaction.get.action>internacional    #rule defs>dos    #rule defs>An?is    tag by.ce/002    tag enderenco-002.2end    '''    nt_z=mdTb.Zeus_Mode    mdTb.Zeus_Mode=False    #    lr_obj_model=mdNeural.get_ontology('layer_obj_index_model',[],'igor.moraes') # identificar os defs de caracteristica    if len(lr_obj_model) == 0:        lr_obj_model2=mdNeural.mdLayer()        lr_obj_model2.name='layer_obj_index_model'        lr_obj_model.append(lr_obj_model2)    lr_obj_class=mdNeural.get_ontology('layer_obj_index_model_class',[],'igor.moraes') # contem os defs para identificar uma categoria    if len(lr_obj_class) == 0:        lr_obj_class2=mdNeural.mdLayer()        lr_obj_class2.name='layer_class_index_model'        lr_obj_class.append(lr_obj_class2)    #print  'lr_obj_model[0]:',lr_obj_model[0]    obj_foco2.append(lr_obj_model[0])    #print  'lr_obj_class[0]:',lr_obj_class[0]    obj_foco2.append(lr_obj_class[0])    def create_fact(lr,tipo_fact,prod_class=False):     lr_to_lnk=lr.get_links('FACT')     if len(lr_to_lnk)==0:      cmp_fc=False      for i in lr_to_lnk:       if i.lr.name == tipo_fact:         cmp_fc=True         obj_foco2.append(i)         return i      if not cmp_fc:        layl=mdNeural.mdLayer()        layl.name=tipo_fact        tps=layl.set_topico('purp-destin')        if not prod_class:         layl.set_nr_ch(tps,'purp-adere-product','defs')        else:         layl.set_nr_ch(tps,'purp-adere-class','defs')        #======================================        obj_foco2.append(layl)        return layl
    for lr_p in obj_foco:      tps=lr_p.get_topico('defs')      if tps != None :       fct=create_fact(lr_obj_model[0],'def_product'+lr_p.name)       tp_r=fct.get_topico('rule')       if tp_r == None:        tp_r=fct.set_topico('rule')       # criar um fact para definir o produto em questao       for tp in tps.sinapses:        if len(tp.nr.dt) > 0:          fct.set_nr_ch(tp_r,'defs>'+tp.nr.dt[0].lower(),'defs')      #      indkcat=0      for lr_link_cat in i_category2:       #=======================================================       indkcat+=1       new_l_dt=umisc.trim(lr_link_cat).lower()       nmc='def_category'+new_l_dt       #nmc='def_category'+lr_p.name+'-'+str(indkcat)       ts_ob_cat=mdNeural.get_ontology(nmc,[],'igor.moraes')       if len(ts_ob_cat) == 0:        fct=create_fact(lr_obj_model[0],nmc,True) # analiza por classe        tp_r=fct.get_topico('rule')        if tp_r == None:         tp_r=fct.set_topico('rule')        #        tp_rc=fct.get_topico('tag')        if tp_rc == None:         tp_rc=fct.set_topico('tag')        fct.set_nr_ch(tp_rc,new_l_dt,'defs')        #        new_l_dt2=new_l_dt.split(' ')        for new_l_dt in new_l_dt2:         fct.set_nr_ch(tp_r,'defs>'+new_l_dt,'defs')       #=======================================================       '''       indkcat+=1       fct=create_fact(lr_obj_model[0],'def_category'+lr_p.name+'-'+str(indkcat),True) # analiza por classe       tp_r=fct.get_topico('rule')       if tp_r == None:        tp_r=fct.set_topico('rule')       #       new_l_dt=umisc.trim(lr_link_cat)       new_l_dt2=new_l_dt.split(' ')       for new_l_dt in new_l_dt2:        fct.set_nr_ch(tp_r,'interaction.get.action>'+new_l_dt,'defs')       '''      #    mdTb.Zeus_Mode=nt_z    #===========================================================================    for lr_p in obj_foco:     if umisc.trim(lr_p.name) != '':      print 'Prepare post object:',lr_p.name      lr_p.s_post_object_by_data_es(lr_p,usr)
    for lr_p in obj_foco2:     if umisc.trim(lr_p.name) != '':      print 'Prepare post object(2):',lr_p.name      lr_p.s_post_object_by_data_es(lr_p,usr)    return obj_foco

def run( layers,relactionado,startL,usr,stack):  for lay in layers:   rt=runc_layer(lay,usr)  #return


